// Attributes
attribute vec4 a_position;									// Vertex Position							(x, y, z, w)
attribute vec2 a_texCoord0;									// Vertex Texture Coordinate				(u, v)
#if defined(TEXCOORD1)
attribute vec2 a_texCoord1;                                 // Second tex coord for multi-texturing
#endif
#if defined(SKINNING)
attribute vec4 a_blendWeights;								// Vertex blend weight, up to 4				(0, 1, 2, 3) 
attribute vec4 a_blendIndices;								// Vertex blend index int u_matrixPalette	(0, 1, 2, 3)
#endif

// Uniforms
uniform mat4 u_worldViewProjectionMatrix;					// Matrix to transform a position to clip space
#if defined(SOFT_TRANSPARENT_EDGES)
uniform mat4 u_worldViewMatrix;								// Matrix to tranform a position to view space
uniform mat4 u_inverseTransposeWorldViewMatrix;				// Matrix to transform a normal to view space
#endif
#if defined(SKINNING)
uniform vec4 u_matrixPalette[SKINNING_JOINT_COUNT * 3];		// Array of 4x3 matrices
#endif
#if defined(SOFT_TRANSPARENT_EDGES)
uniform vec3 u_cameraPosition;                 				// Position of the camera in view space
#endif
#if defined(TEXTURE_REPEAT)
uniform vec2 u_textureRepeat;								// Texture repeat for tiling
#endif
#if defined(TEXTURE_OFFSET)
uniform vec2 u_textureOffset;								// Texture offset
#endif

// Varyings
varying vec2 v_texCoord0;									// Texture Coordinate
#if defined(TEXCOORD1)
varying vec2 v_texCoord1;                                   // Second tex coord for multi-texturing
#endif
#if defined(SOFT_TRANSPARENT_EDGES)
varying vec3 v_cameraDirection;								// Direction the camera is looking at in tangent space
varying vec3 v_normalVector;								// Normal vector in view space
#endif

// Skinning 
#if defined(SKINNING)
vec4 _skinnedPosition;
#if defined(LIGHTING) || defined(SOFT_TRANSPARENT_EDGES)
vec3 _skinnedNormal;
#endif

void skinPosition(float blendWeight, int matrixIndex)
{
    vec4 tmp;
    tmp.x = dot(a_position, u_matrixPalette[matrixIndex]);
    tmp.y = dot(a_position, u_matrixPalette[matrixIndex + 1]);
    tmp.z = dot(a_position, u_matrixPalette[matrixIndex + 2]);
    tmp.w = a_position.w;
    _skinnedPosition += blendWeight * tmp;
}

vec4 getPosition()
{
    _skinnedPosition = vec4(0.0);

    // Transform position to view space using matrix palette with four matrices used to transform a vertex.
    float blendWeight = a_blendWeights[0];
    int matrixIndex = int (a_blendIndices[0]) * 3;
    skinPosition(blendWeight, matrixIndex);

	#if !defined(BATCHING)
		blendWeight = a_blendWeights[1];
		matrixIndex = int(a_blendIndices[1]) * 3;
		skinPosition(blendWeight, matrixIndex);

		blendWeight = a_blendWeights[2];
		matrixIndex = int(a_blendIndices[2]) * 3;
		skinPosition(blendWeight, matrixIndex);

		blendWeight = a_blendWeights[3];
		matrixIndex = int(a_blendIndices[3]) * 3;
		skinPosition(blendWeight, matrixIndex);
	#endif

    return _skinnedPosition;    
}

#if defined(LIGHTING) || defined(SOFT_TRANSPARENT_EDGES)

void skinTangentSpaceVector(vec3 vector, float blendWeight, int matrixIndex)
{
    vec3 tmp;
    tmp.x = dot(vector, u_matrixPalette[matrixIndex].xyz);
    tmp.y = dot(vector, u_matrixPalette[matrixIndex + 1].xyz);
    tmp.z = dot(vector, u_matrixPalette[matrixIndex + 2].xyz);
    _skinnedNormal += blendWeight * tmp;
}

vec3 getTangentSpaceVector(vec3 vector)
{
    _skinnedNormal = vec3(0.0);

    // Transform normal to view space using matrix palette with four matrices used to transform a vertex.
    float blendWeight = a_blendWeights[0];
    int matrixIndex = int (a_blendIndices[0]) * 3;
    skinTangentSpaceVector(vector, blendWeight, matrixIndex);

	#if !defined(BATCHING)
		blendWeight = a_blendWeights[1];
		matrixIndex = int(a_blendIndices[1]) * 3;
		skinTangentSpaceVector(vector, blendWeight, matrixIndex);

		blendWeight = a_blendWeights[2];
		matrixIndex = int(a_blendIndices[2]) * 3;
		skinTangentSpaceVector(vector, blendWeight, matrixIndex);

		blendWeight = a_blendWeights[3];
		matrixIndex = int(a_blendIndices[3]) * 3;
		skinTangentSpaceVector(vector, blendWeight, matrixIndex);
	#endif

    return _skinnedNormal;
}

vec3 getNormal()
{
    return getTangentSpaceVector(a_normal);
}

#if defined(BUMPED)

vec3 getTangent()
{
    return getTangentSpaceVector(a_tangent);
}

vec3 getBinormal()
{
    return getTangentSpaceVector(a_binormal);
}

#endif
#endif
#else
vec4 getPosition()
{
    return a_position;    
}

#if defined(LIGHTING) || defined(SOFT_TRANSPARENT_EDGES)

vec3 getNormal()
{
    return a_normal;
}

#if defined(BUMPED)

vec3 getTangent()
{
    return a_tangent;
}

vec3 getBinormal()
{
    return a_binormal;
}

#endif

#endif 
#endif


void main()
{
    // Get the vertex position
    vec4 position = getPosition();

    // Transform position to clip space.
    gl_Position = u_worldViewProjectionMatrix * position;

    // Texture transformation.
    v_texCoord0 = a_texCoord0;
    #if defined(TEXCOORD1)
    v_texCoord1 = a_texCoord1;
    #endif
    #if defined(TEXTURE_REPEAT)
    v_texCoord0 *= u_textureRepeat;
    #endif
    #if defined(TEXTURE_OFFSET)
    v_texCoord0 += u_textureOffset;
    #endif
	#if defined(SOFT_TRANSPARENT_EDGES)
	vec4 positionWorldViewSpace = u_worldViewMatrix * position;
	v_cameraDirection = u_cameraPosition - positionWorldViewSpace.xyz;
	// Transform normal to view space.
	mat3 normalMatrix = mat3(u_inverseTransposeWorldViewMatrix[0].xyz, u_inverseTransposeWorldViewMatrix[1].xyz, u_inverseTransposeWorldViewMatrix[2].xyz);
	vec3 normal = getNormal();
    v_normalVector = normalMatrix * normal;
	#endif
}

